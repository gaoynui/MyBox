## leetCode笔记

```
1.多个数组合成一个最小数问题，可逐个考虑a*10+b<b*10+a
```

```
2.巴什博弈：一堆物品有n个，两人轮流从物品中取1~m个，最后取光者胜。
  结论：满足n%(m+1) != 0 先手必赢
  分析：
      （1）当n=m+1，无论先取者拿走多少个，后取者都可以一次性拿完
      （2）当n=(m+1)*x+s(x为任意自然数，s<=m)，先取者拿走s个，后取者拿走k个，先取者再拿走m+1-k个，剩下(m+1)*(x-1)个，这样先取者必赢
      （3）所以在某次取完之后留给对方(m+1)*x个就能获胜
      （4）总结上面规律即n%(m+1)!=0时先取者一定会赢
  延申：两人轮流报数，最少报一个，最多报10个，先报到100获胜。第一轮结束后每一轮都是第一轮的影子，而两人每次至少报10+1，所以后者必不可能报到100。
```

```
3.丑数：质因数只包含2，3，5的正整数。找出第n个丑数，1为丑数。
  结论：采用三指针从1开始，最初三个丑数index都为0，当某个丑数index对应的数乘以2/3/5取最小时存入丑数数组，对应的index自增。
  分析：
  	（1）先设置一个dp数组表示当前已经找出并排列好的丑数数组；
	（2）再定3个指针：i,j,k表示将当前已经排好的数组元素 *2，*3，*5 所得的数组（实际上，因为所得的数字最终会加入唯一的排序数组dp，所以并不用真正将3个数组建立起来）
	（3）因为排序后数组*2，*3，*5得到的也是已经排序数组，接下来的目的就是从这3个虚拟数组中的头元素中取得最小那个值；（实际上并不会出现3个数组）所以关键就是如何用这3个指针进行选择。
	（4）（关键）实际上排序并不是在加入排序数组后才整理排序，而是每次用老元素*2，*3，*5生成新元素的时候，选择最小的加入达到排序目的，这个时候指针移动就起到作用了，如下过程所示：
-----------------------------------------------------
已经排好的数组，先放进第一个丑数1:[1]
排好数组*2 ：[1]*2=2
排好数组*3 ：[1]*3=3
排好数组*5 ：[1]*5=5
选结果中最小的数加入数组，此时明显是2，新的排序数组为[1,2]；
-----------------------------------------------------
已经排好的数组:[1，2]------此时上次结果中，2，3，5只用到了2；但3明显是这次需要加入的数；既然2已经加入，再去对比2没意义了，那么就将 （*2的指针） [1]转向下一位[2]，对比 （下一个元素*2 和3，5）的大小，取最小的加入；
排好数组*2 ：[2]*2=4
排好数组*3 ：[1]*3=3
排好数组*5 ：[1]*5=5
选结果中最小的数加入数组，此时明显是2，新的排序数组为[1,2,3]；
-----------------------------------------------------
已经排好的数组:[1，2，3]------3已经加入，移动它的指针到排序数组下一位；
排好数组*2 ：[2]*2=4
排好数组*3 ：[2]*3=6
排好数组*5 ：[1]*5=5
选结果中最小的数加入数组，此时明显是4，新的排序数组为[1,2,3,4]；
依次类推；可以看到，实际上，只需将指针进行分别移动就可以了；所以要做出3个指针；
-----------------------------------------------------
维护3个值val2,val3,val5，表示将当前排列好数组 分别*2，*3，*5所得的结果数；
因为可能3组数出现重复现象，所以要判断是否重复后再加入
```

```
4.拒绝采样。用rand7()实现rand10()
  （1）如果我们调用两次rand7()，就可以生成[1,49]内的随机数
  （2）取其中的40个用来实现rand10()，拒绝剩下的9个数
  （3）|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
      | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
      | 2 | 8 | 9 | 10| 1 | 2 | 3 | 4 |
      | 3 | 5 | 6 | 7 | 8 | 9 | 10| 1 |
      | 4 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
      | 5 | 9 | 10| 1 | 2 | 3 | 4 | 5 |
      | 6 | 6 | 7 | 8 | 9 | 10| * | * |
      | 7 | * | * | * | * | * | * | * |
      *表示被拒绝的数，剩下40个数表示[1,10]概率相同
```

```
5.桶排序。给定一个无序数组，找出数组在排序之后，相邻元素之间最大的差值。数组个数大于2。
	结论：使用桶排序
	分析：
		（1）前提1：如果每个元素都有一个桶，则每个桶有且仅有一个元素。减少桶的数量，必存在有多于1个元素的桶。
		（2）前提2：如果一个数组为等差递增数组，那么最大间距t=(max-min)/(n-1)。任意向左向右移动其中某个元素，t一定会增加。所以t是满足相同间距、元素数量的数组的[相邻元素之间最大差值]最小值。
		（3）前提3：桶的大小都是相同的，每个桶之间的间距也是固定的。之所以相邻桶之间存在最大间距，因为一个桶可不必装满。则间距为前一个桶的最大值和后一个桶的最小值差值。
		（4）选择合适的桶的大小b=⌊(max−min)/(n−1)⌋
		（5）所有n个元素被分为k=⌈(max−min)/b⌉个桶
		（6）第i个桶保存的值区间：[min+i∗b, min+(i+1)∗b)
		（7）将每个元素放入对应桶中：⌊(num−min)/b⌋
		（8）遍历n个元素，比较k-1个相邻桶找到最大间距
```

```
6.线段树。常用来解决某个区间的统计问题，序列某个区间的最值、和。
n个元素构成的线段树有2n-1个节点。
线段树:
	二叉树。
	每个节点代表一个区间，节点的权值是该区间的最小值。
{5，9，7，4，6，1}
```

<img src="https://pic1.zhimg.com/80/v2-d42ed6aa663ef610eee0bc8386087cd5_720w.jpg" alt="{5,9,7,4,6,1}" style="zoom:80%;" />

```
查询区间[1,4]最小值：
1.从第0个根节点开始，根节点区间[0,5]包含查询区间，选择左右子树中最小值较小的。
2.递归
	[0,5]->[0,2]->[0,1]左边到[0,0]，[0,1]两个节点，[0,0]节点的区间不在查询区间内，返回无穷大；[0,1]节点区间为查询区间子区间，返回最小值9。
	[0,5]->[3,5]右边到[3,4]，[5,5]两个节点，[3,4]节点区间包含在查询区间内，返回4；[5,5]区间不在查询区间，返回无穷大。
3.根节点结合递归返回，[0,2]节点返回7，[3,5]节点返回4，根节点返回4。
代码：
class Node {
	int start;//区间左端点
	int end;//区间右端点
	int data;//该节点的值
}
public int findMin(int index, int start, int end) {
	Node node = nodes[index];
	// 查询区间以外的统一返回极大值
	if (node.start > end || node.end < start) return Integer.MAX_VALUE;
	// 如果当前节点区间为查询区间子区间，返回当前节点最小值
	if (node.start >= start && node.end <= end) return node.data;
	// 其他情况对左右子树递归
	return Math.min(findMin((index<<1) + 1, start, end), findMin((index<<2) + 1, start, end));
}
```

```SHI
7.泊松分酒问题。有一个12品脱的酒瓶，里面装满了白酒，另有8品脱和5品脱空瓶各一个。请分出6品脱的酒。
结论：当两个小瓶子最大公约数为1时可调出任何整数。
分析：定义规则:
     大瓶只能倒入中瓶；
     中瓶只能导入小瓶；
     小瓶只能导入大瓶；
     若小瓶子被倒空，立即从中瓶倒入小瓶子。
实施：
     12 8 5
     ——————
     12 0 0             12出现
     4 8 0              4,8出现
     4 3 5              3,5出现
     9 3 0              9出现
     9 0 3 
     1 8 3              1出现
     1 6 5              6出现
     6 6 0
     6 1 5              
     11 1 0             11出现
     11 0 1 
     3 8 1 
     3 4 5
     0 7 5             7出现
     5 7 0
     5 2 5             2出现
     10 2 0            10出现
原理:
    设有大，中，小三个瓶子容量分别为C1,C2,C3,需要倒出的容量是R。
    设大瓶子倒出X次,从小瓶子中倒入大瓶子Y次。
    由大瓶子累计倒出总共C2*X的酒，而由小瓶子倒入大瓶子一共C3*Y的酒。
    最终，小瓶子和中瓶子剩余的酒为C2*X-C3*Y。
    问题转化为不定方程C2*X - C3*Y = R是否有正整数解。
```

```
8.小白鼠试毒药问题。1000瓶药水，其中1瓶是毒药，服用后一小时毒发，毒药可以无限稀释，一小时内用几只小白鼠能够找出毒药。
原理：考察二进制，类似于bitMap(bitmap见https://www.cnblogs.com/dragonsuc/p/10993938.html)
分析：
	设有三只白鼠，可以组合成：
	000 = 0
	001 = 1
	010 = 2
	100 = 3
	011 = 4
	101 = 5
	110 = 6
	111 = 7
	即确定2^3=8个瓶子。1，3，5，7号瓶子混合给鼠1；2，4，6，7给鼠2；3，5，6，7给鼠3。根据鼠的存活情况判断。
	
	则1000瓶需要10(2^10)只白鼠即可判断。
变体：
	1.如果可以测两轮，10只鼠最多可以测多少瓶中的一瓶毒药。
		（1）第一轮死掉的小鼠不被替代。
			小鼠三种状态：第一轮死，第二轮死，两轮都没死。
			则可以用三进制，3^10。0表示没问题，1表示第一轮死，2表示第二轮死。则对含编码为1第一轮混合味，含编			码为2第二轮混合味。
			00 = 0
			01 = 1
			02 = 2
			10 = 3
			11 = 4
			12 = 5
			20 = 6
			21 = 7
			22 = 8
			第一轮：1，4，7给鼠一；3，4，5给鼠二
			第二轮：
				都没死：
					1，3，4，5，7没毒。
					2，5，8鼠一；6，7，8鼠二
                  鼠一死，鼠二活：
                 	  1，4，7中有毒；3，4，5没毒。则1，7中有毒
                 	  6，7，8鼠二
                  鼠一活，鼠二死同理。
       	（2）第一轮死掉的小鼠可以被替代。
       		2^10*2^10
         总结：
         	N只鼠，可以测两轮，最多可以测多少瓶中的一瓶毒药：
         	不能替代：(N + 1) ^ 10
         	能替代:2 ^ (N * 2)
   2.16瓶水一瓶有毒，用多少只小白鼠能测出14瓶无毒的水。
   		16瓶用二进制表示XXXX，取3只小白鼠来测，测出的状态为XXX，则毒在XXX0或XXX1中。剩下14瓶无毒。
   		1，3，5，7，9，11，13，15鼠一；2，3，6，7，10，11，14，15鼠二；4，5，6，7，12，13，14，15鼠三。
   		剩下以为为0或1，排除，则剩下14瓶必没毒(小鼠测过)。
```

