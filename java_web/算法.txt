栈：
push(&s, x)进栈
pop(&s, &x)出栈
s.top 栈顶指针

队列：
EnQueue(&q,x)入队
DeQueue(&q, &x)出队
q.rear/q.front 队尾头指针，队尾进队头出
队头指针指向对头位置，队尾指针指向队尾下一个位置
队满：(q.rear + 1) % MaxSize = q.front
队列元素：(q.rear - q.front + Maxsize) % Maxsize


二叉树：
所有结点数等于所有度数加1

查找：
折半查找
B树

排序：
复杂度与顺序无关：一堆（堆排）海归（归并）选（选择）老友
元素移动次数与初始位置无关：基数
一遍循环一定有元素在最终位置：
简单、快速、冒泡、堆（一堆剪刀快跑）

插入排序：
a[0]哨兵；2-n循环，与前一个比较；将后面移位；插入。

快速排序：
重复向前向后扫描换位；N躺结束会有N个以上元素在最终位置。
递归，找到partition点。

选择排序：
从后面找最小元素与当前元素交换。

归并排序：
辅助数组B复制A；三个下标表示A,B和结果数组；将剩余数复制到结果数组。

堆排序的空间复杂度O(1)，平均时间复杂度O(nlog2n)

